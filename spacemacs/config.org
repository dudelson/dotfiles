#+TITLE: Emacs Configuration
#+AUTHOR: David Udelson
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes :comments no
* general
Tell emacs my name and email address
#+BEGIN_SRC emacs-lisp
  (defun make-email-addr (name domain ext)
    (concat name "@" domain "." ext))
  (setq user-full-name "David Udelson"
        user-mail-address (make-email-addr "david" "davidudelson" "com"))
#+END_SRC

Make spacemacs use UTF-8 by default (I don't know why this isn't already a
default...).
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
#+END_SRC
** scrolling
Setting ~scroll-consevatively~ to a crazy high value makes sure that the point
is always on the screen and fixes some issues I had early on with the scrolling
being really sudden and jerky.

I like to have an appreciable ~scroll-margin~; i.e. the point can never get less
than 10 lines from the top or bottom of the screen. This is useful if I jump to
a definition, because I'm guaranteed to have 10 lines of context on either side.

#+BEGIN_SRC emacs-lisp
  (setq-default
   scroll-margin 10
   scroll-conservatively 1000000
   )
#+END_SRC
** whitespace                                                                             :revisit:
Spacemacs has a toggle that highlights whitespace, but what kind of whitespace
is highlighted is controlled by this setting. See also
~dotspacemacs-whitespace-cleanup~.

#+BEGIN_SRC emacs-lisp
  (setq-default whitespace-style '(face
                                   trailing
                                   tabs
                                   spaces
                                   space-before-tab
                                   indentation
                                   space-after-tab
                                   space-mark
                                   tab-mark))
#+END_SRC
** fill column
I enable the fill column indicator by default in programming modes and set the
color to go well with my default theme (solarized dark).

#+BEGIN_SRC emacs-lisp
  (setq-default fci-rule-color "#073642")
  (add-hook 'prog-mode-hook (lambda () (spacemacs/toggle-fill-column-indicator-on) nil))
#+END_SRC
** unicode
This makes it convenient to input hexadecimal unicode character codes using C-q.
#+BEGIN_SRC emacs-lisp
  (setq-default read-quoted-char-radix 16)
#+END_SRC
* evil-mode
~evil-escape-key-sequence~ allows me to define an alternative to emacs' ~C-g~ and
spacemacs' default ~f d~.

Because I sometimes press these escape sequence keys out of order,
~evil-escape-unordered-key-sequence~ allows ~k j~ to be interpreted the same as
~j k~.

The default spacemacs behavior is to move the cursor back one character when I
switch from insert-state to normal-state. This really annoys me, so I disabled it.
#+BEGIN_SRC emacs-lisp
  (setq-default
   evil-escape-key-sequence "jk"
   evil-escape-unordered-key-sequence t
   evil-move-cursor-back nil
   )
#+END_SRC

I also have a whole bunch of custom keybindings for evil-mode. I'm used to
emacs-style ~C-a~ and ~C-e~ for jumping to the beginning and end of a line,
respectively, so I add those to ~evil-insert-state~. In order to do this, I have
to free up ~C-a~ by moving ~evil-paste-last-insertion~ to ~C-p~, which makes
more sense anyway.
#+BEGIN_SRC emacs-lisp
  (define-key evil-insert-state-map (kbd "C-p") 'evil-paste-last-insertion)
  (define-key evil-insert-state-map (kbd "C-a") (kbd "C-o ^"))
  (define-key evil-insert-state-map (kbd "C-e") (kbd "C-o $"))
#+END_SRC

I rebound the keys for incrementing and decrementing numbers because I rebound
~C-a~ above and ~C-x~ is a common prefix arg in emacs. I kind of like ~+~ and
~-~ more anyway, they're easier for me to remember.
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "+") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "-") 'evil-numbers/dec-at-pt)
#+END_SRC
* search
I use the following search methods:
    - *avy*: great for jumping around. I use this very very often, which is why
      it's bound to ~s~.
    - *evil-snipe*: enhanced evil-mode commands for ~f~, ~F~, ~t~, ~T~, ~/~, and
      ~?~. For jumping around I also use these quite often.
    - *helm-swoop*: better for actually searching than isearch or
      evil-search-forward. I use this less than the jumping commands, which is
      why this command is under the ~g~ prefix instead of being bound to ~/~,
      for example.
    - *evil-search-forward*: sometimes this functionality is better than
      helm-swoop (for example if I need to do the same commands to a bunch of
      occurances of a search), so I keep it around. Note that there are two
      pairs of search functions: ~evil-search-forward~ is just a vim-like
      interface to the built-in emacs isearch, and ~evil-ex-search-forward~ is a
      pure evil implementation that tries to mimic vim's search as closely as
      possible. See [[https://emacs.stackexchange.com/questions/24896/difference-between-evil-search-forward-and-evil-ex-search-forward][here]] for more details. Note that because my spacemacs
      editing style is "vim", evil-search-module is set to evil-search, which
      means if I don't use evil-ex-search-* a lot of things won't work as
      expected.
#+BEGIN_SRC emacs-lisp
  ;; first turn off evil-snipe-mode (but not evil-snipe-override-mode) so that
  ;; s and S are not bound
  (evil-snipe-mode 0)
  (evil-snipe-override-mode 1)
  ;; define my custom search keys
  (define-key evil-normal-state-map (kbd "/") 'evil-snipe-s)
  (define-key evil-normal-state-map (kbd "?") 'evil-snipe-S)
  (define-key evil-normal-state-map (kbd "g/") 'evil-ex-search-forward)
  (define-key evil-normal-state-map (kbd "g?") 'evil-ex-search-backward)
  (define-key evil-normal-state-map (kbd "n") 'evil-ex-search-next)
  (define-key evil-normal-state-map (kbd "N") 'evil-ex-search-previous)
  (define-key evil-normal-state-map (kbd "s") 'evil-avy-goto-char-2)
  (define-key evil-normal-state-map (kbd "S") 'evil-avy-goto-line)
  (define-key evil-normal-state-map (kbd "gs") 'helm-swoop)
  ;; this is going to be bound to "resume last helm-swoop search"
  ;; but I don't think that function exists yet, so I have to write it myself
  ;; (define-key evil-normal-state-map (kbd "gS") 'helm-swoop-resume)
  (define-key evil-normal-state-map (kbd "C-s C-s") 'avy-resume)
  (define-key evil-normal-state-map (kbd "C-s k l") 'avy-kill-whole-line)
  (define-key evil-normal-state-map (kbd "C-s k r") 'avy-kill-region)
  (define-key evil-normal-state-map (kbd "C-s c l") 'avy-copy-line)
  (define-key evil-normal-state-map (kbd "C-s c r") 'avy-copy-region)
  (define-key evil-normal-state-map (kbd "C-s m l") 'avy-move-line)
  (define-key evil-normal-state-map (kbd "C-s m r") 'avy-move-region)
  (define-key evil-normal-state-map (kbd "C-s r l") 'avy-kill-ring-save-whole-line)
  (define-key evil-normal-state-map (kbd "C-s r r") 'avy-kill-ring-save-region)
  (define-key evil-normal-state-map (kbd "C-s C-d") 'avy-goto-word-or-subword-1)
  (define-key evil-normal-state-map (kbd "C-s C-i") 'avy-isearch)
  (define-key evil-normal-state-map (kbd "C-s s")   'avy-goto-symbol-1)

  ;; also disable SPC w l and SPC w h for now in order to build more efficient habits
  (spacemacs/set-leader-keys "wl" nil)
  (spacemacs/set-leader-keys "wh" nil)
#+END_SRC
* indentation                                                                              :revisit:
I've found it's easiest to put all tab- and indentation-related settings in one
place, because they're sort of tricky to get right, and this prevents me from
going crazy. Coming from vim, emacs' tab settings seem like they try to do too
much by default, and a lot of these settings attempt to make the tab key more
predictable for me.

First, prevent ~<~ and ~>~ from rounding to the nearest tabstop
#+BEGIN_SRC emacs-lisp
  (setq-default evil-shift-round nil)
#+END_SRC

Next, try to minimize unexpected tab behavior by telling the tab key to only
indent.
#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-always-indent t
   c-tab-always-indent t)
#+END_SRC

From [[https://www.emacswiki.org/emacs/IndentationBasics]]: True tab characters are
displayed as being ~tab-width~ spaces wide. It's best to have these three
settings always agree with each other to prevent interoperability problems with
editors that can't separate tab width from indentation settings.
#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-width 4
   c-basic-offset 4
   cperl-indent-level 4)
#+END_SRC

Set the tab-stop list according to the tab width, and automatically indent when
return is pressed
#+BEGIN_SRC emacs-lisp
  (setq-default tab-stop-list (number-sequence tab-width 120 tab-width))
  (global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

In text-mode, I want zero tab shenanigans. This was the only way I could come up
with to get the tab key to reliably insert a tab without simultaneously screwing
up things like ~c c~ and ~o~ in evil normal-state, which also depend on
~insert-line-function~. It suits my needs fine.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook (lambda ()
                              (define-key evil-insert-state-local-map (kbd "<tab>")
                                (lambda () (interactive) (insert-tab)))))
#+END_SRC

Lastly, javascript and react have a whole bunch of indentation-related variables
to set.
#+BEGIN_SRC emacs-lisp
  (setq-default
   js2-basic-offset tab-width css-indent-offset
   tab-width web-mode-markup-indent-offset tab-width
   web-mode-css-indent-offset tab-width web-mode-code-indent-offset
   tab-width web-mode-attr-indent-offset tab-width)
#+END_SRC
* backups
Taken from this [[http://pragmaticemacs.com/emacs/auto-save-and-backup-every-save/][Pragmatic Emacs]] post. Note that by default Spacemacs turns
backups off completely (but not autosave). See [[https://github.com/syl20bnr/spacemacs/issues/8947][this issue]] for more details.
#+BEGIN_SRC emacs-lisp
  (setq
   make-backup-files t     ; take backups!
   backup-by-copying t     ; don't clobber symlinks
   kept-new-versions 10    ; keep 10 latest versions
   kept-old-versions 0     ; don't bother with old versions
   delete-old-versions t   ; don't ask about deleting old versions
   version-control t       ; number backups
   vc-make-backup-files t  ; backup version controlled files
   backup-directory-alist `((".*" . ,(concat user-emacs-directory ".cache/backup"))))
#+END_SRC
* japanese input
Migemo is a package provided by the spacemacs japanese layer which allows
searching for japanese text using romaji. In order for it to do this, you have
to point it at the dictionary file (provided by installing migemo on your
system). I also setup japanese input using mozc. I use mozc for this purpose
system-wide, with the difference that emacs is the only application that does
not require ibus.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "migemo"
    (setq-default migemo-dictionary "/usr/share/migemo/utf-8/migemo-dict"))
  (setq-default default-input-method "japanese-mozc")
#+END_SRC
* keybindings
** private
#+BEGIN_SRC emacs-lisp
  (defvar du/toggle-planner-enabled nil
    "Whether the planner view is enabled")

  (defvar du/toggle-planner-window-config nil
    "Saves the window config so it can be restored later")

  (defun du/toggle-planner ()
    "Toggles my custom planner view
    When toggled on, displays my org file on the left, and my custom agenda on the right.
    When toggled off, restores the window layout from before the last time it was toggled on"
    (interactive)
    (if du/toggle-planner-enabled
        ;; restore previous window configuration
        (set-window-configuration du/toggle-planner-window-config)
      ;; otherwise store window configuration so it can be restored later
      (setq du/toggle-planner-window-config (current-window-configuration))
      (find-file "~/s/doc/gtd/current.org")
      (delete-other-windows)
      (split-window-right-and-focus)
      (find-file "~/s/doc/gtd/notes.md"))
    ;; toggle the thingy
    (setq du/toggle-planner-enabled (not (symbol-value du/toggle-planner-enabled)))
    (message "Toggled planner view %s" du/toggle-planner-enabled))

  (defun du/open-kaizen ()
    (interactive)
    (find-file "~/s/doc/org/topics/kaizen.org"))

  ;; NOTE: due to an idiosyncracy of how emacs handles symlinks, I cannot use
  ;; (concat dotspacemacs-directory "relative/path") to refer to the files to
  ;; tangle or org-babel-tangle-file will close the config.org buffer after
  ;; tangling, which is pretty annoying. In this case, I'd rather deal with the
  ;; annoyance of having to change the absolute paths every time they change.
  (defun du/retangle-reload ()
    (interactive)
    (let ((src "/home/david/s/dot/spacemacs/config.org")
          (dst "/home/david/s/dot/spacemacs/config.el"))
      (if (file-exists-p src)
          (org-babel-tangle-file src dst)
        (message "Could not find config.org")))
    (let ((src "/home/david/s/dot/spacemacs/org-config.org")
          (dst "/home/david/s/dot/spacemacs/org-config.el"))
      (if (file-exists-p src)
          (org-babel-tangle-file src dst)
        (message "Could not find org-config.org")))
    (dotspacemacs/sync-configuration-layers)
    (let ((f "/home/david/s/dot/spacemacs/config.el"))
      (if (file-exists-p f)
          (load-file f)
        (message "Could not find config.el")))
    (let ((f "/home/david/s/dot/spacemacs/org-config.el"))
      (if (file-exists-p f)
          (load-file f)
        (message "Could not find org-config.el"))))

  ;; open my planner from anywhere in emacs
  (spacemacs/set-leader-keys "oo" 'du/toggle-planner)
  ;; org-capture keybinding that isn't as easily confused with the keybinding for
  ;; calc-dispatch (SPC a c)
  (spacemacs/set-leader-keys "oc" 'org-capture)
  ;; open kaizen file
  (spacemacs/set-leader-keys "ok" 'du/open-kaizen)
  ;; retangle and reload literate config
  (spacemacs/set-leader-keys "or" 'du/retangle-reload)
  (spacemacs/declare-prefix "o" "private")
#+END_SRC

Here's a function to copy an auto-filled region of text, automatically joining
all the lines together in the process ("unfilling" the region). This makes the
copied text suitable for pasting into an online document without altering the
auto-filled emacs buffer.
#+BEGIN_SRC emacs-lisp
  (defun du/unfill-and-copy (beg end)
    (interactive (list (region-beginning) (region-end)))
    (unfill-region beg end)
    (ox-clip-formatted-copy (region-beginning) (region-end))
    (fill-region (region-beginning) (region-end)))

  (spacemacs/set-leader-keys "oq" 'du/unfill-and-copy)
#+END_SRC
** override spacemacs built-ins
Make SPC b y do the same thing as SPC f y, because I can never remember which
one it is.
#+BEGIN_SRC emacs-lisp
  (spacemacs/set-leader-keys "by" 'spacemacs/show-and-copy-buffer-filename)
#+END_SRC

I never use the actions which are bound by default to SPC b C-d and SPC b C-D.
However, I quite frequently use the SPC b d and SPC b D commands with the
universal arg, which closes the window in addition to the buffer. I think five
keystrokes is too many for keys I use so frequently, therefore we're going to do
some reshuffling.
#+BEGIN_SRC emacs-lisp
  (defun du/close-buffer-window ()
    (interactive)
    (spacemacs/kill-this-buffer '(4)))

  (defun du/ace-close-buffer-window ()
    (interactive)
    (spacemacs/ace-kill-this-buffer '(4)))

  (spacemacs/set-leader-keys "b C-d" 'du/close-buffer-window)
  (spacemacs/set-leader-keys "b C-S-d" 'du/ace-close-buffer-window)
#+END_SRC

Currently SPC ' isn't bound to anything, so it's safe to use as a shortcut for
SPC b b (so I don't have to move my hand so much for this common key sequence).
#+BEGIN_SRC emacs-lisp
  (spacemacs/set-leader-keys "'" 'helm-mini)
#+END_SRC

And I think just to get in the habit of it I'm going to temporarily rebind
SPC b b so it doesn't work.
#+BEGIN_SRC emacs-lisp
  (spacemacs/set-leader-keys "bb"
    (lambda ()
      (interactive)
      (message "Use SPC ' !")))
#+END_SRC
* layer-specific
A lot of these settings are grouped with their respective spacemacs layers.
** android development
I've never actually developed anything in android, but I tried once, which is
why I have these settings. They may or may not work. Basically we tell the
android package where the android SDK is located on the system and try to set
some reasonable defaults for gradle.

#+BEGIN_SRC emacs-lisp
  (setq-default
   android-mode-sdk-dir "/home/david/.local/android/android-sdk-linux"
   android-mode-builder 'gradle
   android-mode-root-file-plist '(ant "AndroidManifest.xml"
                                  maven "AndroidManifest.xml"
                                  gradle "gradlew"))
#+END_SRC
** auto-completion (includes snippets)
Most of the autocompletion settings are for the spacemacs auto-completion layer
in init.el, but here I try to clean up the suggestions window a bit, and define
a less awkward keybinding for ~hippie-expand~.

#+BEGIN_SRC emacs-lisp
  (setq-default company-tooltip-align-annotations t)
  ;; note: this overrides `evil-scroll-line-up`
  (define-key evil-insert-state-map (kbd "C-y") 'hippie-expand)
#+END_SRC
** elfeed
#+BEGIN_SRC emacs-lisp
  ;; (defface elfeed-starred-feed
  ;;   '((t :foreground "#859900"))
  ;;   "Marks all entries from elfeed blogs tagged 'star'")

  ;; (push '(star elfeed-starred-feed)
  ;;       elfeed-search-face-alist)
#+END_SRC
** latex
Xetex is the only engine that appears to be compatible with all of the LaTeX
packages I use.
#+BEGIN_SRC emacs-lisp
  (setq-default TeX-engine 'xetex)
#+END_SRC

*NOTE*: The spacemacs LaTeX layer appears to use its own variable,
=latex-build-command=, in place of the AUCTeX variable =latex-run-command=. I do
not know why this is the case, but it seems likely that at least some LaTeX
layer functions depend on the latter variable, since the layer is built on top
of AUCTeX. Therefore if you experience build errors, check to see if
=latex-run-command= is involved. If it is, you'll have to figure out a way to
keep these two variables in sync.

Set the pdf viewer for LaTeX compilation output.
#+BEGIN_SRC emacs-lisp
  (setq-default TeX-view-program-selection '((output-pdf "PDF Tools")))
#+END_SRC

Turn off some of the "magic" LaTeX features that format things in the buffer. I
find these annoying.
#+BEGIN_SRC emacs-lisp
  (setq magic-latex-enable-block-highlight nil
        magic-latex-enable-pretty-symbols nil
        magic-latex-enable-suscript nil
        font-latex-fontify-script nil)
#+END_SRC

Prevent latex from jumping to matching dollar signs (also annoying).
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook (lambda () (setq blink-matching-paren nil)))
#+END_SRC
** pdf-tools
#+BEGIN_SRC emacs-lisp
  ;; open pdfs scaled to fit page
  (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t)
  ;; add hook to turn off global-disable-mouse-mode when pdf-tools loads
  (add-hook 'pdf-view-mode-hook (lambda () (global-disable-mouse-mode -1)))
#+END_SRC
** rust
Enable racer, which provides code-completion for rust, and point it to the rust
source.
#+BEGIN_SRC emacs-lisp
  (setq-default
   racer-rust-src-path "/usr/src/rust/src"
   rust-enable-racer t)
#+END_SRC
* misc
Stuff that I can't find a place for anywhere else
** abbrevs
Things that I'm too lazy to type correctly
#+BEGIN_SRC emacs-lisp
  (define-abbrev-table 'global-abbrev-table '(
                                              ("Flase" "False")
                                              ))
  ;; stop asking whether to save newly added abbrev when quitting emacs
  (setq save-abbrevs nil)
  ;; turn on abbrev mode globally
  (setq-default abbrev-mode t)
#+END_SRC
** highlight escape sequences and format strings
#+BEGIN_SRC emacs-lisp
  ;; highlight escape sequences
  (hes-mode)
  ;; highlight format strings in C-like languages
  (defvar font-lock-format-specifier-face 'font-lock-format-specifier-face
    "Face name to use for format specifiers.")

  (defface font-lock-format-specifier-face '((t (:foreground "OrangeRed1")))
    "Font Lock mode face used to highlight format specifiers."
    :group 'font-lock-faces)

  (add-hook 'c-mode-common-hook
            (lambda ()
              (font-lock-add-keywords nil
                                      '(("[^%]\\(%\\([[:digit:]]+\\$\\)?[-+' #0*]*\\([[:digit:]]*\\|\\*\\|\\*[[:digit:]]+\\$\\)\\(\\.\\([[:digit:]]*\\|\\*\\|\\*[[:digit:]]+\\$\\)\\)?\\([hlLjzt]\\|ll\\|hh\\)?\\([aAbdiuoxXDOUfFeEgGcCsSpn]\\|\\[\\^?.[^]]*\\]\\)\\)"
                                         1 font-lock-format-specifier-face t)
                                        ("\\(%%\\)" 1 font-lock-format-specifier-face
                                         t)))))
#+END_SRC
** hooks
Various hooks that do useful things.
#+BEGIN_SRC emacs-lisp
  ;; copied from Elvind
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'makefile-mode-hook 'whitespace-mode)
  ;; turn on fill column indicator by default
  ;; don't color delimiters in C-like code
  (add-hook 'c-mode-hook (lambda () (rainbow-delimiters-mode -1)))
  ;; save buffer on focus lost
  ;; (add-hook 'focus-out-hook 'save-buffer)
  ;; disable relative line numbers on focus lost
  ;; (add-hook 'focus-out-hook 'nlinum-relative-off)
  ;; (add-hook 'focus-in-hook 'nlinum-relative-on)
  ;; auto-refersh magit status buffer when files change
                                          ;(add-hook 'after-save-hook 'magit-after-save-refresh-status)
  ;; disable evilification of Info pages
  (evil-set-initial-state 'Info-mode 'emacs)
#+END_SRC

* experiments
** disable mouse globally
Right now I'm trying to figure out how to disable the mouse globally. No dice
yet, but here is my latest attempt. I simply installed the ~disable-mouse~
package from melpa and make a call to enable it here. It works for some things,
but not others.

#+BEGIN_SRC emacs-lisp
  (global-disable-mouse-mode)
#+END_SRC
* temporary fixes
Fixes helm buffers causing one window to disappear in a split view.
See [[https://github.com/syl20bnr/spacemacs/issues/9984][this spacemacs issue]].
#+BEGIN_SRC emacs-lisp
  (setq helm-always-two-windows nil)
#+END_SRC
* credits
This configuration was inspired by the configurations of many others:
    - [[https://github.com/ipburbank][Istvan Burbank]]
    - [[https://ogbe.net/emacsconfig.html][Dennis Ogbe]]
